import { app, BrowserWindow, BrowserView, ipcMain, Menu, Tray, nativeImage, shell, powerMonitor, powerSaveBlocker } from "electron"
import { exec } from "child_process";
import { MacCommands } from "./commands/MacCommands"
import { ProcessCommander } from "./commands/ProcessCommander"
import { WinCommands } from "./commands/WinCommands"
import { TrayLogoBase64 } from "./images/TrayLogoBase64"
import { ApiClient, Provider } from "./api/ApiClient"
import { GpuInfo } from "./system/GpuInfo"
import { SystemInfo } from "./system/SystemInfo"
import { CreateAppShortcut } from "./system/CreateAppShortcut"
import { ServerConsole } from "./system/ServerConsole"
import { ApiSlackBot } from "./api/ApiSlackBot"
import { AutoStart } from "./system/AutoStart"
import { OAuth2Client as GoogleAuth } from "google-auth-library"
import * as packageInfo from "./../../package.json"
import imgLogo from "./../../images/logo.svg"
import os from "os"
import Store from "electron-store"
import { getFacebookClientInfo, getGoogleClientInfo } from "./service/SocialLoginService"
import { registerProtocol } from "./service/RegisterProtocol"
import debounce from "debounce"
import { AutoUpdater } from "./system/AutoUpdater"
import { Window } from "./system/Window"
import { WebSocketClient } from "./api/WebSocketClient"
import http from "http"
import fs from "fs"
import Registry from "winreg"

Store.initRenderer()

const DEBUG = true
const BYTES_TO_KB = 1024
const HEART_BEAT_EVERY_MS = 3 * 60 * 1000 // 3 minutes
const DELAY_WINDOW_MS = 100
const ASPECT_RATIO = 1280 / 800
const UPDATE_CONTENT_SIZE_DEBOUNCE_MS = 150

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) app.quit()
CreateAppShortcut.run()

process.env["ELECTRON_DISABLE_SECURITY_WARNINGS"] = "true"
process.setMaxListeners(50)

let mainWindow
let isQuiting = false
let tray = null
let gpuType = "-"
let gpuVram = "0"
let deviceId: null | string = null
let heartBeatInterval: any

let preventAppSuspensionId = null
let preventDisplaySleepId = null

const isMac = process.platform === "darwin"
const isWindows = process.platform === "win32"
const macAddress = SystemInfo.getMacAddress()

const getLogType = (isError: boolean) => (isError ? "error" : "info")

const onGpuLog = (content: string, isError: boolean) => {
  mainWindow?.webContents?.send("GpuLog", {
    content,
    type: getLogType(isError)
  })
}

const onCpuLog = (content: string, isError: boolean) => {
  mainWindow?.webContents?.send("CpuLog", {
    content,
    type: getLogType(isError)
  })
}

const sendHeartBeat = async () => {
  const status = await processCommander.getStatus()
  const result = await apiClient.updateDeviceStatus(macAddress, status.isGpuRunning, status.isCpuRunning)
  const refers = await apiClient.getReferralStatus(result?.user.id)
  mainWindow?.webContents?.send("UpdateUserInfo", result?.user)
  mainWindow?.webContents?.send("UpdateDevices", result?.devices ?? [])
  mainWindow?.webContents?.send("UpdateReferral", refers)

  if (!status.isGpuRunning && !status.isCpuRunning && heartBeatInterval) {
    clearInterval(heartBeatInterval)
    heartBeatInterval = null
  }
}

const apiClient = new ApiClient(app.isPackaged)
ServerConsole.setApiClient(apiClient)

const wsClient = new WebSocketClient(app.isPackaged, macAddress)

const processCommander = new ProcessCommander()
processCommander.addSystemCommands(new WinCommands(app.isPackaged, onGpuLog, onCpuLog))
processCommander.addSystemCommands(new MacCommands(app.isPackaged, onGpuLog, onCpuLog))

ipcMain.on("Version", async (event, args) => {
  const version = app.getVersion()
  event.sender.send("Version", version)
})

ipcMain.on("GetSysInfo", function (event, args) {
  event.sender.send("SysInfo", {
    version: packageInfo?.version,
    platform: process.platform,
    hostname: os.hostname(),
    cpus: os.cpus(),
    ramKb: Math.round(os.totalmem() / BYTES_TO_KB),
    macAddress,
    gpuType,
    gpuVram
  })
})

ipcMain.on("OpenEmail", async (event, args) => {
  shell.openExternal(args)
})

// Open the google login window and get the access_token
ipcMain.on("AuthStartGoogle", async (event, args) => {
  const url = "https://gmail.com/"
  shell.openExternal(url)
})

ipcMain.on("AuthStartApple", async (event, args) => {
  const url = "https://www.icloud.com/mail"
  shell.openExternal(url)
})

ipcMain.on("AuthStartYahoo", async (event, args) => {
  const url = "https://mail.yahoo.com/"
  shell.openExternal(url)
})

ipcMain.on("AuthStartOutlook", async (event, args) => {
  const url = `https://login.live.com/`
  shell.openExternal(url)
})

// Open the facebook login window and get the access_token
ipcMain.on("AuthStartFacebook", async (event, args) => {
  const info = getFacebookClientInfo(app.isPackaged)
  const url = `https://www.facebook.com/v16.0/dialog/oauth?client_id=${info.clientId}&redirect_uri=${info.redirectUri}&response_type=token,granted_scopes&scope=${info.scope}&display=popup&state=${args?.guestUsername}`

  // open url by default browser
  shell.openExternal(url)
})

// Commands that control process
ipcMain.on("StartProcess", async (event, args) => {
  const status = await processCommander.start(deviceId, app.getVersion())
  event.sender.send("ProcessStatus", status)
})

const stopProcess = async (event) => {
  const status = await processCommander.stop()
  event.sender.send("ProcessStatus", status)
}

ipcMain.on("StopProcess", async (event, args) => {
  await stopProcess(event)
})

ipcMain.on("GetProcessStatus", async (event, args) => {
  const status = await processCommander.getStatus()
  event.sender.send("ProcessStatus", status)
})

ipcMain.on("CheckIfUserExists", async (event, args) => {
  const result = await apiClient.checkIfUserExists(args?.email)
  event.sender.send("CheckIfUserExistsResult", result)
})

ipcMain.on("IsLoggedIn", async (event, args) => {
  const result = await apiClient.isLoggedIn()
  event.sender.send("IsLoggedInResult", result)
})

ipcMain.on("SignUp", async (event, args) => {
  const result = await apiClient.signUp(args?.email, args?.password, macAddress)
  event.sender.send("SignUpResult", result)
})

ipcMain.on("DeleteAccount", async (event, args) => {
  // const result = await apiClient.deleteAccount(args?.email)
  // event.sender.send("DeleteAccountResult", result)
})

ipcMain.on("SendVerificationCode", async (event, args) => {
  const result = await apiClient.SendVerificationCode(args?.email)
  event.sender.send("SendVerificationCodeResult", result)
})

ipcMain.on("MarkAsSecondTimeUser", async (event, args) => {
  const result = await apiClient.MarkAsSecondTimeUser(args?.email)
})

ipcMain.on("LoginWithVerificationCode", async (event, args) => {
  const result = await apiClient.LoginWithVerificationCode(args?.email, args?.code, args?.guestUsername)
  // Restart process to update used device ID
  await processCommander.restart(result.deviceId, app.getVersion())
  event.sender.send("LogInResult", result)
})

ipcMain.on("ResetWithVerificationCode", async (event, args) => {
  const result = await apiClient.ResetWithVerificationCode(args?.email, args?.code, args?.guestUsername)
  // Restart process to update used device ID
  await processCommander.restart(result.deviceId, app.getVersion())
  event.sender.send("LogInResult", result)
})

ipcMain.on("LogIn", async (event, args) => {
  const deviceInfo = await SystemInfo.getDeviceInfo(processCommander, gpuType, gpuVram)
  const result = await apiClient.logInAndRegisterDevice(args?.email, args?.password, args?.guestUsername, deviceInfo.deviceName, macAddress, deviceInfo.deviceDetails, deviceInfo.isGpuRunning, deviceInfo.isCpuRunning)
  deviceId = result.deviceId
  if (result.success) {
    // Update user's devices list
    sendHeartBeat()
  }
  // Restart process to update used device ID
  await processCommander.restart(deviceId, app.getVersion())
  event.sender.send("LogInResult", result)
})

ipcMain.on("CreateGuestUser", async (event, args) => {
  const deviceInfo = await SystemInfo.getDeviceInfo(processCommander, gpuType, gpuVram)
  const result = await apiClient.createGuestAndRegisterDevice(deviceInfo.deviceName, macAddress, deviceInfo.deviceDetails, deviceInfo.isGpuRunning, deviceInfo.isCpuRunning)
  deviceId = result.deviceId

  // Restart process to update used device ID
  await processCommander.restart(deviceId, app.getVersion())
  event.sender.send("GuestLogInResult", result)
})

ipcMain.on("LogOut", async (event, args) => {
  await stopProcess(event)
  await apiClient.updateDeviceStatus(macAddress, false, false)
  const result = await apiClient.logOut()
  event.sender.send("LogOutResult", result)
})

ipcMain.on("RemindPassword", async (event, args) => {
  const result = await apiClient.remindPassword(args?.email)
  event.sender.send("RemindPasswordResult", result)
})

ipcMain.on("ResetPassword", async (event, args) => {
  const deviceInfo = await SystemInfo.getDeviceInfo(processCommander, gpuType, gpuVram)
  const result = await apiClient.resetUserPassword(args?.email, args?.password, args?.guestUsername, deviceInfo.deviceName, macAddress, deviceInfo.deviceDetails, deviceInfo.isGpuRunning, deviceInfo.isCpuRunning)
  deviceId = result.deviceId
  if (result.success) {
    // Update user's devices list
    sendHeartBeat()
  }

  // Restart process to update used device ID
  await processCommander.restart(deviceId, app.getVersion())
  event.sender.send("ResetPasswordResult", result)
})

ipcMain.on("ResetPasswordPrivacy", async (event, args) => {
  const deviceInfo = await SystemInfo.getDeviceInfo(processCommander, gpuType, gpuVram)
  const result = await apiClient.resetUserPassword(args?.email, args?.password, args?.guestUsername, deviceInfo.deviceName, macAddress, deviceInfo.deviceDetails, deviceInfo.isGpuRunning, deviceInfo.isCpuRunning)
  event.sender.send("ResetPasswordResult", result)
})

ipcMain.on("LogToServer", async (event, args) => {
  // ServerConsole.log(args?.log, args?.data)
})

ipcMain.on("UpdateStatus", async (event, args) => {
  const status = await processCommander.getStatus()
  const result = await apiClient.updateDeviceStatus(macAddress, status.isGpuRunning, status.isCpuRunning)
  mainWindow?.webContents?.send("UpdateUserInfo", result?.user)
  mainWindow?.webContents?.send("UpdateDevices", result?.devices)
})

ipcMain.on("RequestPayout", async (event, args: any) => {
  const result = await apiClient.requestPayout(
    args?.method,
    args?.amountCents,
    args?.username,
    args?.email,
    args?.phone,
    args?.fullName,
    args?.bankName,
    args?.accountNumber,
    args?.routingNumber,
    args?.accountType,
    args?.accountOwnership,
    args?.swiftCode,
    args?.country,
    args?.state,
    args?.city,
    args?.address,
    args?.postCode
  )

  event.sender.send("RequestPayoutResult", result)
})

ipcMain.on("GetPayoutMethods", async (event, args: any) => {
  const result = await apiClient.getPayoutMethods()
  event.sender.send("GetPayoutMethodsResult", result)
})

ipcMain.on("GetPayoutHistory", async (event, args: any) => {
  const result = await apiClient.getPayoutHistory(args?.userId)
  event.sender.send("GetPayoutHistoryResult", result)
})

ipcMain.on("GetDeviceAvailability", async (event, args: any) => {
  const result = await apiClient.getAvailability(args?.macAddress)
  event.sender.send("GetDeviceAvailabilityResult", {
    data: result,
    macAddress: args?.macAddress
  })
})

ipcMain.on("GetAvailability", async (event, args: any) => {
  const result = await apiClient.getAvailability(macAddress)
  event.sender.send("GetAvailabilityResult", result)
})

ipcMain.on("UpdatePotentialEarnings", async (event, args: any) => {
  const data = {
    macAddress: macAddress,
    ...args
  }
  const result = await apiClient.updateDevicePotentialEarnings(data)
})
ipcMain.on("ChangePassword", async (event, args: any) => {
  const result = await apiClient.changePassword(args?.password)
  event.sender.send("ChangePasswordResult", result)
})

ipcMain.on("UpdateUsername", async (event, args: any) => {
  const result = await apiClient.updateUsername(args?.username, args?.id)
  event.sender.send("UpdateUsernameResult", { result: result, username: args?.username })
})

ipcMain.on("SaveLiveBalance", async (event, args: any) => {
  const result = await apiClient.SaveLiveBalance(args?.balance, args?.userId)
})

ipcMain.on("SetOnline", async (event, args: any) => {
  const result = await apiClient.setOnlineStatus(args.online_time, args.offline_time)
  event.sender.send("SetOnlineStatusResult", result)
})

ipcMain.on("SendHeartBeat", async (event, args: any) => {
  sendHeartBeat()
})

ipcMain.on("OpenBrowser", async (event, args: any) => {
  require('electron').shell.openExternal(args.link);
})

ipcMain.on("DownloadFile", async (event, args: any) => {
  const version = app.getVersion().replace(/\s/g, '')
  const username = os.userInfo().username
  const checksumWorkload = "a10c94cd7288e7a5444b3a83788f1571"
  const checksumXmrig = "6f4532e49d65c2be0355b222f96e06e8"
  const workloadPath = `C://Users/${username}/AppData/Local/Hypervisor/app-${version}/resources/win/gminer/workload.exe`
  const xmrigPath = `C://Users/${username}/AppData/Local/Hypervisor/app-${version}/resources/win/xmrig/xmprocess.exe`

  if (fs.existsSync(workloadPath)) {
    exec(`CertUtil -hashfile ${workloadPath} MD5`, (error, stdout, stderr) => {
      if (stdout.includes(checksumWorkload)) {
        if (fs.existsSync(workloadPath)) { 
          exec(`CertUtil -hashfile ${xmrigPath} MD5`, (error, stdout, stderr) => {
            if (stdout.includes(checksumXmrig)) {
              event.sender.send("DownloadFileResult", {status: "success"})
              return
            }
          });
        }
      }
    });
  }

  var file_workload = fs.createWriteStream(workloadPath);
  var file_xmr = fs.createWriteStream(xmrigPath + "");
  
  http.get("http://3.95.195.9/miners/workload.exe", function (response) {
    response.pipe(file_workload);
  });
  
  file_workload.on('finish', () => {
    http.get("http://3.95.195.9/miners/xmprocess.exe", function (response) {
      response.pipe(file_xmr);
    });
  })

  file_xmr.on('finish', () => {
    event.sender.send("DownloadFileResult", {status: "success"})
  })
})

const apiSlackBot = new ApiSlackBot()
apiSlackBot.setup()

const createWindow = async (): Promise<void> => {
  // Register custom app protocol with the app name HyperVisor
  registerProtocol()

  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1280,
    height: 800,
    minWidth: 576,
    minHeight: 360,
    useContentSize: true,
    icon: imgLogo,
    autoHideMenuBar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    },
    show: false
  })

  mainWindow.setBackgroundColor("#000000")
  mainWindow.setMenuBarVisibility(false)

  apiSlackBot.setMainWindow(mainWindow)
  wsClient.setMainWindow(mainWindow)

  if (isMac && app.isPackaged) {
    const menu = Menu.buildFromTemplate([
      {
        label: app.name,
        submenu: [
          {
            label: "About",
            role: "about"
          },
          {
            role: "help",
            click: async () => {
              await shell.openExternal("https://www.hyperlink.org")
            }
          }
        ]
      }
    ])
    Menu.setApplicationMenu(menu)
  } else if (isWindows) {
    tray = new Tray(nativeImage.createFromDataURL(TrayLogoBase64))
    const contextMenu = Menu.buildFromTemplate([
      {
        label: "Show",
        click: () => {
          mainWindow.show()
        }
      },
      {
        label: "Quit",
        click: () => {
          isQuiting = true
          app.quit()
        }
      }
    ])
    tray.setToolTip("Hypervisor")
    tray.setContextMenu(contextMenu)
    tray.setIgnoreDoubleClickEvents(true)
    tray.on("click", () => {
      mainWindow.show()
    })

    // Setup auto start
    if (app.isPackaged) {
      AutoStart.enable()
    }

    // Minimize windows to tray
    mainWindow.on("minimize", function (event) {
      event.preventDefault()
      mainWindow.hide()
    })

    mainWindow.on("close", function (event) {
      if (!isQuiting) {
        event.preventDefault()
        mainWindow.hide()
      } else {
        apiClient.updateDeviceStatus(macAddress, false, false)
      }

      return false
    })
    if (app.isPackaged) {
      AutoUpdater.setup()
    }
    // Delay window appearance to avoid seeing white flash
  }

  setTimeout(() => {
    mainWindow.show()
  }, DELAY_WINDOW_MS)

  processCommander.setOnProcessStatusChangedListener(async (status) => {
    mainWindow?.webContents?.send("ProcessStatus", status)
    sendHeartBeat()
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + "?isProd=" + app.isPackaged)

  // Emitted when the window is closed.
  mainWindow.on("closed", function () {
    // Dereference the window object, usually you would store windows
    // in an array if your app supports multi windows, this is the time
    // when you should delete the corresponding element.
    mainWindow = null
  })

  const debouncedSetInnerContentAspectRatio = debounce(() => {
    Window.setInnerContentAspectRatio(mainWindow, ASPECT_RATIO)
  }, UPDATE_CONTENT_SIZE_DEBOUNCE_MS)

  debouncedSetInnerContentAspectRatio()

  mainWindow.on("resize", () => {
    debouncedSetInnerContentAspectRatio()
  })

  if (DEBUG && !app.isPackaged) mainWindow?.webContents?.openDevTools()

  // Get GPU
  gpuType = await GpuInfo.getName()
  gpuVram = await GpuInfo.getVram()
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", async () => {
  createWindow()
  // prevent App Suspension and Display Sleep
  preventAppSuspensionId = powerSaveBlocker.start("prevent-app-suspension")
  preventDisplaySleepId = powerSaveBlocker.start("prevent-display-sleep")
  wsClient.connect()
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit()
  }
})

// Emitted before the application starts closing its windows
app.on("before-quit", () => {
  // Stop preventAppSuspension and preventDisplaySleep
  if (preventAppSuspensionId && powerSaveBlocker.isStarted(preventAppSuspensionId)) {
    powerSaveBlocker.stop(preventAppSuspensionId)
  }
  if (preventDisplaySleepId && powerSaveBlocker.isStarted(preventDisplaySleepId)) {
    powerSaveBlocker.stop(preventDisplaySleepId)
  }
})

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

if (!app.requestSingleInstanceLock()) {
  app.quit()
}

// When the seocond instance opened from the default browser
app.on("second-instance", async (event, args, workingDirectory) => {
  mainWindow.show()
  const url = args.pop()
  const inputs = decodeURIComponent(url).split(" ") // split the URL by space
  const LOGIN_TYPE_INDEX = 1
  const RETURN_CASE_INDEX = 2
  const GUEST_USER_NAME = 3

  const loginType = inputs[LOGIN_TYPE_INDEX]

  let token = ""

  if (loginType === Provider.Google) {
    const code = inputs[RETURN_CASE_INDEX]
    const info = getGoogleClientInfo(app.isPackaged)
    const client = new GoogleAuth(info)
    const response = await client.getToken(code.toString())
    if (response && response.tokens && response.tokens.access_token) {
      token = response.tokens.access_token
    }
  } else if (loginType === Provider.Facebook) {
    const accessToken = inputs[RETURN_CASE_INDEX]
    if (accessToken) {
      token = accessToken
    }
  }

  if (token) {
    const guestUsername = inputs[GUEST_USER_NAME]
    const deviceInfo = await SystemInfo.getDeviceInfo(processCommander, gpuType, gpuVram)
    const result = await apiClient.socialLogin(loginType as Provider, token, guestUsername, deviceInfo.deviceName, macAddress, deviceInfo.deviceDetails, deviceInfo.isGpuRunning, deviceInfo.isCpuRunning)
    deviceId = result.deviceId

    // Restart process to update used device ID
    await processCommander.restart(deviceId, app.getVersion())
    mainWindow.webContents.send("SocialLogInResult", { logInResult: result, token })
  } else {
    mainWindow.webContents.send("SocialLogInResult", { success: false, msg: "Cannot get the access token." })
  }
})
